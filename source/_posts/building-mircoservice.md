---
title: 《微服务设计》读书笔记
date: 2016-08-03T19:13:08.000Z
layout: post
author: kris.zhang
header-img: head.jpg
wechat_pig: wechat.jpg
mathjax: true
tags:
  - 微服务
  - 读书笔记
---

全书可以分为三大块

1. `思想`：阐明微服务的意义，演化式架构师，采用微服务的基本原则以及微服务的_不适用_场景
2. `方法论`：如何建模（定义边界DDD）、集成、分解、部署、测试、监控、安全
3. `规模化微服务`：属于方法论范畴，但是我这里单独拿出来，它包括：康威定律、规模化指南

<!-- toc -->

 # 第一篇 思想

## 第一章 微服务

> 把因为相同原因而变化的东西聚合到一起，而把因为不同原因而变化的东西分离开来。

### 什么是微服务？

作者这里只用了一句话解释微服务：微服务就是一些协同工作的小而自洽的服务。因此微服务有几个关键点：

1. `很小而专注` 很小是多小？这个其实涉及到了微服务粒度，任何一个系统都没有一概而论的原则，多小就需要依靠我们的实践经验了。
2. `协同工作` 协同意味着耦合，微服务之间的耦合一般通过api定义进行解耦。那么微服务就是应该按照api进行划分么？作者建议我们应该用业务来划分微服务而不是仅仅从技术上。
3. `微服务是自洽的` 自洽实际上意味着我们的每一个微服务都是一个独立的个体，就像峰群中的蜜蜂一样，他们能单独维护，单独迭代，单独部署，单独测试，单独发布。这其实也就是意味着极低的耦合，只依赖接口。

### 微服务的好处是？

- `技术异构` ：极少的耦合意味着每个微服务都可以使用不同的技术实现，比如有的微服务使用java语言，有的使用go语言。
- `弹性` ：遇到故障的时候，能够将其像舱壁一样隔离，不会影响整个系统，
- `扩展` ：遇到性能问题的时候，只需要横向扩展有性能瓶颈的服务即可
- `简化部署` ：修改服务内一小段代码，只需要发布该服务，不需要发布整个系统
- `与组织结构相匹配` ：披萨原则，一个team够分一个披萨的，说明这个team人数够了
- `可组合性` ：就是说单个微服务能够快速重用
- `对可替代性的优化` ：可替代性意味着再重新实现一遍微服务的成本非常低

### 与其他分解技术区别？

1. `SOA` ：微服务架构是SOA的一种特定方法
2. `共享库` ：适用于与业务无关的代码
3. `模块` ：可能更适用于传统软件，比如eclipse等

### 我的理解：

微服务的概念实际上从名字就可以看出来，'微'意味着小和专注，'服务'意味着就需要自洽和被调用（耦合）。需要注意的是，微服务并不意味着没有耦合。

微服务之所以能够带来上述好处本质是因为：`小而精且独立`。代码规模小了，依赖少了，自然会有上述好处。但这也会带来诸多问题，后面书中会一一讨论如何解决，他们也即是微服务方法论的淫威所至。

针对书中与其他分解技术的区别，个人觉得不同技术方案适用于不同的技术场景，这个观点再平常不过了。微服务不是万能药。共享库和模块机制无法或很难解决微服务所面临的场景；同理微服务也无法或很难解决共享库和模块机制面临的场景，因此只有更合适，没有最合适。

现在回过头来想一想公司推行的dubbo，能够解决服务之间的依赖调用，但是对于技术异构这块，是否值得商榷呢？应为dubbo就已经将你限定死了，你无法跨语言。再加上服务治理功能，框架耦合度实在是太强了。想想今日头条的thrift顿觉开朗。

## 第二章 演化式架构师

> 规则对于智者来说是指导，对于愚蠢者来说是遵从

作者很谦虚，开篇就说了本章内容是他自己的个人观点，让大家求同存异。

### 架构师是什么？

我们软件架构师与建筑工程师有很多方面是不同的，大部分人都误解了我们，因此我们应该重新定义架构师的含义。作者觉得软件架构师与城市规划师比较相似，他们都需要有一个`演化视角`，即架构师需要专注于一个大的方向上面，什么应该做，什么不应该做。让参与开发的人员与使用这个系统的用户一样开心。这很难，如何开始？分区！如同城市规划师，他关注城市划分的每一个区域，而不会关心区域中的一户人家。同理软件架构师应该关注区域间发生的事情，而不应该过多关注区域之间的事情。当然有的时候也要关注内部，比如我们不能允许团队选择10种技术栈，这样招聘比较困难。

### 原则性方法？

1. 技术选型应该与公司战略目标一致
2. 将系统的设计原则摆在明面上，时刻牢记
3. 通过实践保证原则能够得到实施，并巩固原则
4. 实践与原则相结合

作者给了一个真实的表格，我觉得很有参考价值，不过，在中国公司真的能行得通吗？

### 要求的标准是什么？

- `清晰的监控` ：比如用graphite收集指标，nagios检测健康状态
- `标准的接口` ：选用几种即可，如何处理版本，如何处理url规范
- `架构的安全性` ：比如标准的返回码，异常的处理，连接池，熔断器等等

### 如何治理代码？

有的时候，达成共识是个好主意，但是话时间保证人们遵守这个共识就没那么有趣了。作者根据实际经验给出了两个比较奏效的办法：

- `使用范例` ：给出你规范的示例代码，注意一定要是生产环境下的，并且可用的。程序员都喜欢看代码。直观！
- `剪裁服务代码模板`：给一个代码模板大家都用它即可。

### 架构师如何看待技术负债？

架构师应该从更高的层次出发，理解如何权衡负债和紧急特性的取舍。应该维护一个技术负债列表，定期回顾检查。

### 关于团队建设

作者给了一个类比，讨论架构师对一个团队的影响和团队的自主话语权之间的思考。他就像教小孩骑自行车一样，小孩子初学骑车很容易摔倒，如果你每次都去搀扶他，他始终都学不会。如果当他骑向川流不息的马路和池塘时，你就需要马上抓紧他们。架构师和团队就是这样的关系，即使你是对的，也有可能会破坏与团队的关系。所以，架构师不容易啊！

### 我的理解

如果说上学那会，我一定会说这一章太没意思了，根本看不懂。工作了几年以后，各种事情见得多了，也就与作者产生了共鸣，又顿觉醍醐灌顶。就拿代码治理来说，我也曾制定过一些规范，会议上大家都是一致赞同，而实战中却又没有几个人能够严格遵守。现在回过头想想，我们将前后端接口格式定义为一个JsonData模板类是多么的明智。这正好用了作者所提出的剪裁服务代码模板。

关于技术负债我也感同身受，有一次技术需求，我们将系统中所有的@Autowired改成了@Resource注解，这样我们能够统一使用JSR标准，避免各种注解的滥用。但是QA不愿意了，他说你们这么做没有意义。实际上作者已经给出了我的回答----定期检查技术负债，避免系统负债越积越多。

# 第二篇 方法论

## 第三章 服务建模技术

> 细胞只所以存在，是因为细胞膜定义了什么在细胞内，什么在细胞外，并且确定了什么物质可以通过细胞膜。

### 什么是好的服务？

本章核心内容是教我们如何对服务进行建模，在讲如何建模之前作者先提出了一个问题----什么样的服务是好服务？然后给出了我们常见的两个概念，松耦合以及进紧内聚。为了保证松耦合实际上我们应该去限制两个服务之间的调用形式数量，减少他们之间的直接通信。针对紧内聚，我们希望吧相关的行为聚集在一起，把不相关的行为放在别处。

### 界限上下文

作者提出了一个限界上下文的概念，根据Evans在《领域驱动设计》锁描述，任何一个给定的领域都包含多个`限界上下文`，每个限界上下文中的东西分成两个部分，一部分是不需要与外部通信，另一部分是需要与外部通信。我个人觉得说的挺废话的，但是往往玄妙就藏在这种废话这种。大自然也是如此，细胞只所以存在，是因为细胞膜定义了什么在细胞内，什么在细胞外，并且确定了什么物质可以通过细胞膜。

针对不同的上下文之间，实际上是存在一个共享模型的，这种模型能够隐藏两个上下文中的详细信息。我觉得有点类似我们REST接口的传输对象（DTO），这种传输对象就是一种共享模型。作者觉得服务部应该过早的划分，过早划分的代价非常高，团队应该能准确识别出非常稳定的边界之后，在将单块系统拆分成微服务。对于单块系统，我们可以先通过模块机制划分层次，然后在进行微服务拆分，这样效果更好。

### 关于技术边界

作者给了一个他们之前遇到的实际例子，说明他们那个架构是`洋葱架构`，因为有很多层，而且当纵切这些层次时，他只想哭。这说明，我们应该谨慎采用技术边界划分。除非你的话费是合理的，比如想达到某个性能目标。

### 我的理解

这里我忽略了一些其他章节，就挑主要的说，对我个人来讲，界限上下文的概念，还有那个细胞的比喻，以及共享模型，都是比较有意思的。

## 第四章 集成

> 唯一不变的就是变化

作者认为集成是微服务相关技术中最重要的一个。好则自洽，不好则懵逼。

### 协议选型的原则？

所谓微服务集成技术，我的理解就是服务之间的通信技术。那么我们用很多比如SOAP，REST，PB，等等，那么选择这些技术的理由？或者说我们选择他们是为了什么？

- `避免`

### 共享数据库可以吗？

### 是同步还是异步？

### 编排还是协同？

### RPC会有什么问题？
