---
title: 《微服务设计》读书笔记
date: 2016-08-03T19:13:08.000Z
layout: post
author: kris.zhang
header-img: head.jpg
wechat_pig: wechat.jpg
mathjax: true
tags:
  - 微服务
  - 读书笔记
---

全书可以分为三大块

1. `思想`：阐明微服务的意义，演化式架构师，采用微服务的基本原则以及微服务的_不适用_场景
2. `方法论`：如何建模（定义边界DDD）、集成、分解、部署、测试、监控、安全
3. `规模化微服务`：属于方法论范畴，但是我这里单独拿出来，它包括：康威定律、规模化指南

<!-- toc -->

 # 第一篇 思想

## 第一章 微服务

> 把因为相同原因而变化的东西聚合到一起，而把因为不同原因而变化的东西分离开来。

### 什么是微服务？

作者这里只用了一句话解释微服务：微服务就是一些协同工作的小而自洽的服务。因此微服务有几个关键点：

1. `很小而专注` 很小是多小？这个其实涉及到了微服务粒度，任何一个系统都没有一概而论的原则，多小就需要依靠我们的实践经验了。
2. `协同工作` 协同意味着耦合，微服务之间的耦合一般通过api定义进行解耦。那么微服务就是应该按照api进行划分么？作者建议我们应该用业务来划分微服务而不是仅仅从技术上。
3. `微服务是自洽的` 自洽实际上意味着我们的每一个微服务都是一个独立的个体，就像峰群中的蜜蜂一样，他们能单独维护，单独迭代，单独部署，单独测试，单独发布。这其实也就是意味着极低的耦合，只依赖接口。

### 微服务的好处是？

- `技术异构` ：极少的耦合意味着每个微服务都可以使用不同的技术实现，比如有的微服务使用java语言，有的使用go语言。
- `弹性` ：遇到故障的时候，能够将其像舱壁一样隔离，不会影响整个系统，
- `扩展` ：遇到性能问题的时候，只需要横向扩展有性能瓶颈的服务即可
- `简化部署` ：修改服务内一小段代码，只需要发布该服务，不需要发布整个系统
- `与组织结构相匹配` ：披萨原则，一个team够分一个披萨的，说明这个team人数够了
- `可组合性` ：就是说单个微服务能够快速重用
- `对可替代性的优化` ：可替代性意味着再重新实现一遍微服务的成本非常低

### 与其他分解技术区别？

1. `SOA` ：微服务架构是SOA的一种特定方法
2. `共享库` ：适用于与业务无关的代码
3. `模块` ：可能更适用于传统软件，比如eclipse等

### 我的理解：

微服务的概念实际上从名字就可以看出来，'微'意味着小和专注，'服务'意味着就需要自洽和被调用（耦合）。需要注意的是，微服务并不意味着没有耦合。

微服务之所以能够带来上述好处本质是因为：`小而精且独立`。代码规模小了，依赖少了，自然会有上述好处。但这也会带来诸多问题，后面书中会一一讨论如何解决，他们也即是微服务方法论的淫威所至。

针对书中与其他分解技术的区别，个人觉得不同技术方案适用于不同的技术场景，这个观点再平常不过了。微服务不是万能药。共享库和模块机制无法或很难解决微服务所面临的场景；同理微服务也无法或很难解决共享库和模块机制面临的场景，因此只有更合适，没有最合适。

现在回过头来想一想公司推行的dubbo，能够解决服务之间的依赖调用，但是对于技术异构这块，是否值得商榷呢？应为dubbo就已经将你限定死了，你无法跨语言。再加上服务治理功能，框架耦合度实在是太强了。想想今日头条的thrift顿觉开朗。

## 第二章 演化式架构师

> 规则对于智者来说是指导，对于愚蠢者来说是遵从

作者很谦虚，开篇就说了本章内容是他自己的个人观点，让大家求同存异。

### 架构师是什么？

我们软件架构师与建筑工程师有很多方面是不同的，大部分人都误解了我们，因此我们应该重新定义架构师的含义。作者觉得软件架构师与城市规划师比较相似，他们都需要有一个`演化视角`，即架构师需要专注于一个大的方向上面，什么应该做，什么不应该做。让参与开发的人员与使用这个系统的用户一样开心。这很难，如何开始？分区！如同城市规划师，他关注城市划分的每一个区域，而不会关心区域中的一户人家。同理软件架构师应该关注区域间发生的事情，而不应该过多关注区域之间的事情。当然有的时候也要关注内部，比如我们不能允许团队选择10种技术栈，这样招聘比较困难。

### 原则性方法？

1. 技术选型应该与公司战略目标一致
2. 将系统的设计原则摆在明面上，时刻牢记
3. 通过实践保证原则能够得到实施，并巩固原则
4. 实践与原则相结合

作者给了一个真实的表格，我觉得很有参考价值，不过，在中国公司真的能行得通吗？

### 要求的标准是什么？

- `清晰的监控` ：比如用graphite收集指标，nagios检测健康状态
- `标准的接口` ：选用几种即可，如何处理版本，如何处理url规范
- `架构的安全性` ：比如标准的返回码，异常的处理，连接池，熔断器等等

### 如何治理代码？

有的时候，达成共识是个好主意，但是话时间保证人们遵守这个共识就没那么有趣了。作者根据实际经验给出了两个比较奏效的办法：

- `使用范例` ：给出你规范的示例代码，注意一定要是生产环境下的，并且可用的。程序员都喜欢看代码。直观！
- `剪裁服务代码模板`：给一个代码模板大家都用它即可。

### 架构师如何看待技术负债？

架构师应该从更高的层次出发，理解如何权衡负债和紧急特性的取舍。应该维护一个技术负债列表，定期回顾检查。

### 关于团队建设

作者给了一个类比，讨论架构师对一个团队的影响和团队的自主话语权之间的思考。他就像教小孩骑自行车一样，小孩子初学骑车很容易摔倒，如果你每次都去搀扶他，他始终都学不会。如果当他骑向川流不息的马路和池塘时，你就需要马上抓紧他们。架构师和团队就是这样的关系，即使你是对的，也有可能会破坏与团队的关系。所以，架构师不容易啊！

### 我的理解

如果说上学那会，我一定会说这一章太没意思了，根本看不懂。工作了几年以后，各种事情见得多了，也就与作者产生了共鸣，又顿觉醍醐灌顶。就拿代码治理来说，我也曾制定过一些规范，会议上大家都是一致赞同，而实战中却又没有几个人能够严格遵守。现在回过头想想，我们将前后端接口格式定义为一个JsonData模板类是多么的明智。这正好用了作者所提出的剪裁服务代码模板。

关于技术负债我也感同身受，有一次技术需求，我们将系统中所有的@Autowired改成了@Resource注解，这样我们能够统一使用JSR标准，避免各种注解的滥用。但是QA不愿意了，他说你们这么做没有意义。实际上作者已经给出了我的回答----定期检查技术负债，避免系统负债越积越多。

# 第二篇 方法论

## 第三章 服务建模技术

> 细胞只所以存在，是因为细胞膜定义了什么在细胞内，什么在细胞外，并且确定了什么物质可以通过细胞膜。

### 什么是好的服务？

本章核心内容是教我们如何对服务进行建模，在讲如何建模之前作者先提出了一个问题----什么样的服务是好服务？然后给出了我们常见的两个概念，松耦合以及进紧内聚。为了保证松耦合实际上我们应该去限制两个服务之间的调用形式数量，减少他们之间的直接通信。针对紧内聚，我们希望吧相关的行为聚集在一起，把不相关的行为放在别处。

### 界限上下文

作者提出了一个限界上下文的概念，根据Evans在《领域驱动设计》锁描述，任何一个给定的领域都包含多个`限界上下文`，每个限界上下文中的东西分成两个部分，一部分是不需要与外部通信，另一部分是需要与外部通信。我个人觉得说的挺废话的，但是往往玄妙就藏在这种废话这种。大自然也是如此，细胞只所以存在，是因为细胞膜定义了什么在细胞内，什么在细胞外，并且确定了什么物质可以通过细胞膜。

针对不同的上下文之间，实际上是存在一个共享模型的，这种模型能够隐藏两个上下文中的详细信息。我觉得有点类似我们REST接口的传输对象（DTO），这种传输对象就是一种共享模型。作者觉得服务部应该过早的划分，过早划分的代价非常高，团队应该能准确识别出非常稳定的边界之后，在将单块系统拆分成微服务。对于单块系统，我们可以先通过模块机制划分层次，然后在进行微服务拆分，这样效果更好。

### 关于技术边界

作者给了一个他们之前遇到的实际例子，说明他们那个架构是`洋葱架构`，因为有很多层，而且当纵切这些层次时，他只想哭。这说明，我们应该谨慎采用技术边界划分。除非你的话费是合理的，比如想达到某个性能目标。

### 我的理解

这里我忽略了一些其他章节，就挑主要的说，对我个人来讲，界限上下文的概念，还有那个细胞的比喻，以及共享模型，都是比较有意思的。共享模型我们比较常见，比如给前端传递信息的JONS数据，这个JSON数据的格式其实也是一种共享模型，或者我们在DUBBO接口的时候使用AO对象，其实也是共享模型，他隐藏了我们底层的数据结构，这样两端可以独立变化，直接把共享模型想象成一座桥也是很贴切的。

界定上下文的概念

## 第四章 集成

> 唯一不变的就是变化

作者认为集成是微服务相关技术中最重要的一个。好则自洽，不好则懵逼。实际上集成技术，你可以理解为微服务和微服务的通信技术。

### 协议选型的原则？

针对微服务之间的通信，我们有很多协议：SOAP，REST，PB，JSON，XML等等，那么选择这些技术的理由是什么？或者说我们选择他们是为了什么？有哪些原则需要注意的呢？

- `避免破坏性修改`：比如服务端加了一个字段，客户端不升级的话就完蛋了。这种就是破坏性修改，不过一般序列化协议能够支持字段的增加，和删除，对于类型修改就无能为力了。
- `保证API的技术无关性`：比如rest就可以保证技术无关性，但是dubbo就不行。
- `使你的服务易于消费方使用`：理想情况下消费方应该可以使用任何技术来实现。
- `隐藏内部实现细节`：这个就不用说了，所有倾向于暴露内部实现细节的技术都不应该采用。

这些是基本原则，有些我们都比较熟悉，有些也值得我们思考。比如上述的保证技术无关性就值得思考。我们公司大力推行dubbo，阿里巴巴也是，各个公司都在推行。仔细想想dubbo其实制约了技术后面的更新换代。长期来看不利于系统技术探索。

### 共享数据库可以吗？

可以，但是不好。作者觉得共享库会产生_重度耦合_，因为数据库表是最底层的业务抽象了，他的变化会严重导致直接依赖的系统的变化，比如新增字段，变更字段等。但这里我觉得我应该为这种模式平反一下，在业务早期，我们是有节制的可以采用这种模式的，不过是多个服务依赖相同的数据库，但不一定是依赖同一张表。不过，在系统规划的早期就应该区分开来哪些是未来可能要单独迁移出去的表，哪些是在一个业务服务内的表。以后随着业务发展，慢慢的将他们迁移出去，形成多服务接口调用以进一步减少耦合。

### 是同步还是异步？

api的调用分为同步和异步调用，基于事件的调用天生就是异步的。使用同步调用和异步调用，或者事件机制，都不是限定死的，要看场景。这个作者也说了。没有必要再过多的解释。

### 编排还是协同？

编排的意思是使用一个服务，调用多个其他服务，协调整个业务流程，这个可能出现的问题是下游服务变成单纯的CRUD的贫血模型了。这个不难理解，因为你的业务逻辑上移了，下游就非常有可能沦为DAO层。

协同的意思就是事件机制，一个事件发送到事件队列，其他服务消费这个事件（有序或者序）。就是所谓的架构反转。非常流行的一周架构模式。

举一个下单的例子，一个用户下单，会触发订单服务增加订单，库存服务减少库存，短信服务发送短信，那么针对编排就是一个下单服务，顺序调用订单服务，库存服务，通信服务。如果是协同，就是下单服务发送一个时间，然后其他服务去消费。协同模式能够很大程度上的解耦，扩展性也好，但需要一个靠谱的中间件，比如QMQ。

### RPC会有什么问题？

RPC是我们比较常用的技术，比如dubbo框架就是一个RPC框架，JMI、thrift等等。但是我们经常使用的RPC框架在实现微服务的时候会有什么问题呢？

- `技术耦合`：比如DUBBO，绑死到了JAVA技术上。但是可以通过代码生成机制解决这个问题。
- `本地调用和远程调用`：很容易让人误用，将远程调用当成本地调用，从而造成性能问题。
- `脆弱性`：想想接口变动的兼容性问题吧！这个时候你需要所有客户端都需要生成一遍代码。

上述问题，并不意味着RPC很糟糕，对比数据库集成方式，RPC显然有很大的提高。不过我们要使用，也要有所保留，有所注意。

### REST好不好?

先来明确REST跟HTTP是不同的，很多人提到REST自然想到HTTP，HTTP就是一个承载体，REST也可以通过其他协议实现（USB)，只不过HTTP去实现REST要简单的多了，并且HTTP有大量的生态型工具，在HTTP这个生态下你能更方便的开发和调试。

然后作者提到了超媒体作为程序状态引擎，实际上这里的思维是将写死的API变成动态API。这是需要提供中间层的，这个中间层其实就是发现机制。link就是这种思想的很好体现。

使用json还是xml？作者喜欢xml，给了几个解释，但大多说人还是系统json，因为他处理起来太简单了。我这里还要跟作者说，大家喜欢json还有js这个原因。

当然，REST还是尤其缺点的，比如：

1. 无法生成客户端的桩代码
2. WEB服务框架无法很好的支持所有HTTP动词
3. 性能会有问题，想想最新的HTTP2吧
4. 高级的序列化机制得我们自己搞了。RPC框架会集成的

### 基于事件机制好不好？

`RPC`和`REST`都是请求响应模式。事件机制是另种继承模型，也是作者非常推崇的模型，考察他主要有两个方面，一个是服务发布，一个是服务消费。由于事件机制我们太熟悉了，我这里就不啰嗦了。作者的主要观点就是事件机制很好，但异步架构真是挺复杂的，想想各种消息队列的实现，都是面对不同的业务场景，kafka，rocketMQ，QMQ，RabbitMQ，ZeroMQ等等。

服务即状态机的观点其实也是显而易见的。每个服务都是维护自己的那些状态，并通过外部作用改变其状态。RxJava是响应式扩展的java实现，本人学过一些，不过没有在实际中使用过，他比较适用于类似GUI的场景，比如android等。能把观察者模式玩的如此之炫，也是很让人佩服的。其他后面能有场景使用它。

### DRY原则可以用在微服务吗？

不一定可以。为什么这么说，大家都知道应该避免重复代码，将每个服务的公共代码都抽出来形成一个共享库。好，但是也不好。好在避免了重复代码，不好在于，共享库引入了耦合。一旦共享库有了修改，那么所有服务都可能要跟着升级。这种情况已经在现实工作中遇到不止一次了，有人觉得我们应该吧数据库模型映射对象单独一个jar包，然后每个项目引用他。可是一次又一次的升级和重新部署证明这种方式不靠谱。更靠谱的方式是每个项目维护自己的实体，单独升级，单独修改。因此，在微服务设计中，我们应该尽量避免共享库的存在，适当的违反DRY原则。有些通用工具确实可以单独抽象出来，比如类似apache commons或者guava。

关于客户端库的使用，作者建议不要把业务代码写到那里面，只提供协议封装、服务发现、网络通信等。这个是很自然的。各种RPC框架也都是这么做的。

### 按引用访问时什么？

`按引用访问` 开始有点不明白，举个例子就懂了，发货后发邮件通知，一般做法是调用参数有，地址，姓名，当单详情等。然后发邮件服务将信息入队列，之后再发送。但是在队列等待处理的时候，是不是有可能用户修改了电子邮件地址呢？这个时候在发送是有问题的。因此正确做法是调用参数保存邮件地址的引用，比如id=1的邮件地址，当真正发送的时候，在对信息做反查。这个想法挺赞的，我以前没有想过这个问题。

### 如何进行版本控制？

多版本兼容性一直都是服务化最头疼的事情，服务端升级了版本，我们应该尽量向下兼容。有时候可能会产生破坏性修改，这种修改无法兼容原有接口，比如原有接口中删除了一个还在使用的字段。作者给出了几种解决方案：

- `尽可能推迟` 你最好不进行破坏性修改，比如你要删除字段，那么你还是别删除留着吧，你要修改类型，那么你还是增加一个字段吧。
- `及早发现破坏性修改` 比如对于一个不用的字段，赶紧删除，千万不要暴露出去，作者强烈建议使用消费者驱动的契约来及早定位这些问题。所谓消费者契约就是说，要听乙方的。呵呵。
- `使用语义化版本控制` 比如1.0.0，大版本小版本，有什么意义，修bug是1.0.1，新特性1.1.0，大改动2.0.0等等
- `不同接口共存` 这个挺实用的，意味着多接口，单实现。我用的比较多，尤其针对不同既有www，又有touch app 微信等等。
- `多个版本的服务` 这个在做新老系统迁移的时候常用，类似灰度，保留新老两个接口和实现，当发现老接口没有人用的时候，在统一删除。

### 用户界面？

实际上名字不太好理解，用户界面就是说，如果组合API，然后提供用户输出（比如界面）。这也有几种方式，我们最常见的当然是ajax，由js直接通过ajax调用，然后在前端进行数据组合。不过这里有几个人问题，一个是跨域，一个是性能，可以通过api gateway解决。还有一种做法是UI片段组合，比较适用于CMS系统，输出的就是一个渲染好的页面，或者是其一部分。他的问题在于样式一致性。

另一种方案，也是我们目前MICE采用的，就是为前端服务的后端，也叫大前端。一般这个为前端服务的后端使用nodejs，来组合各种API，静态化页面等。不过我们目前流量比较小，看不出什么问题，不知道在对大流量搞并发支持上面是否靠谱。在平常开发中这种模式有一个调试弊端，非常不方便调试。因为你在本地需要部署多个环境，node+tomcat。因此只能去调试接口，集成测试恶心死了。还有一个就是查问题不方便，你需要多定位一层。当然最后作者提出了混合方式，这个不多说了，具体问题具体分析。

### 如何与第三方软件集成？

这里说的第三方软件集成，比如CMS，发布系统，人力资源系统，等等。作者有一个观点：如果某个软件非常特殊，并且它是你的战略性资产的话，那就自己构建，如果不是这么特别的话，那就购买。

针对购买的系统，我们做持续集成真的很恶心，想一想公司的wiki，想修改个bug都难。不过jenkins这种开源软件，我们也有可能面对这种问题，虽然是开源的，但是水深也需要有人去趟。因此作者给出一个好办法，就是把这种可定制的系统封装起来，通过提供api，不暴露实现。作者屡试不爽。或者采用绞杀模式（Strangler Application Pattern）其实就是拦截接口调用，把他们打到新系统上。
